## 关系型数据库


### 码、候选码、主属性、非主属性、主键、外键
- 码：能唯一标识一条记录的属性。
- 候选码：关系中的一组属性(一个或多个)可以唯一标识一个记录、而其真子集不能，则这个属性组成为候选码。 
- 主属性：候选码中出现过的属性。
- 非主属性：候选码中未出现过的属性。比如，性别、年龄之类的在大多数表中都是作为非主属性出现的。 
- 主键：主键是从候选码中选出来的，一个实体集可以有多个候选码，但只能有一个主键。不可重复、不可为空。
- 外键：用来与其他表建立连接，外键是另一个表的主键。

### DDL、DML
- DDL：数据定义语言，建表、改表结构等，操作数据库对象，DBA用的。  
- DML：数据操作语言，对表记录的增删改查等操作，开发人员用的。  
drop、truncate(清空表)是DDL，delte是DML。drop和truncate的操作立即生效，不会将原数据放到rollback segment中，而delete是DML语句，操作会放到rollback segment中，事务提交后才会生效。

### 范式
首先了解函数依赖相关概念：  
- 函数依赖：在属性X的值确定的情况下，属性Y的值也能相应确定，则称Y函数依赖于X，记X -> Y；
- 部分函数依赖：如果X -> Y，而X的真子集X0 -> Y,则称Y部分函数依赖于X。说白了就是X中包含了多个可以充当候选码的属性；
- 完全函数依赖：是相对于部分函数依赖的，还是X -> Y，这次X中的属性去除任何一个都不能确定Y，则称X完全函数依赖于Y;  
- 传递函数依赖，这个顾名思义，可以结合下面的3NF来理解。
- 1NF: 一个属性对应一个类型的值，不能再分了。　　
- 2NF：1NF的基础上消除了非主属性对码的部分函数依赖，根据每个非主属性的函数依赖来分表，确保每个非主属性都完全函数依赖于码。
- 3NF：在2NF的基础上消除了非主属性的传递函数依赖。举个例子，在表(学号，姓名，系名，系主任)中，学号->系名，系名->系主任，这种传递会造成冗余，甚至可能出现异常，所以3NF范式下会给学生和系建两个表，中将通过外键关联。

### 存储过程
存储过程是SQL语句+一些逻辑控制语句，写起来更方便些、也便于下次调用，而且是预编译的，执行速度也要比直接sql快些，但实际互联网开发中很少用到，产品那边可能会用。

### E-R图
实体、属性、联系

### 事务
#### ACID
#### 并发一致性问题
#### 事务隔离
#### 锁

### 索引
#### 聚集索引与非聚集索引
1. 回顾B+树
2. 索引
- 聚集索引：数据行的物理存储顺序和列值的逻辑顺序相同，可以理解为是叶子节点存放的是整条数据，所以一个表只能有一个聚集索引，一般是主键。
- 非聚集索引：数据行的物理存储顺序和列值的逻辑顺序不同，可以理解为叶子节点存放的是指向数据行的物理地址，并且叶子节点中连续的关键字对应的物理地址是不连续的。实际上，通过非聚集索引查到的是索引列的值和对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据(回表二次查询)。
- 覆盖索引(复合索引)：建立两列以上的索引，只查询覆盖索引里的列的数据(最左前缀匹配原则)时不需要进行回表二次查询。
	```sql
	create index index_birthday_and_user_name on user_info(birthday, user_name);
	select user_name from user_info where birthday = '1991-11-1'
	```


参考：[聚集索引与非聚集索引的总结](https://www.cnblogs.com/s-b-b/p/8334593.html)  
[为什么不建议用select *](https://blog.csdn.net/u013240038/article/details/90731874)
[聚集索引,非聚集索引,覆盖索引 原理](https://blog.csdn.net/itguangit/article/details/82145322)

### Mysql基本架构
[一条SQL语句在MySQL中执行过程全解析](https://blog.csdn.net/weter_drop/article/details/93386581)  
mysql分两层：server层和存储引擎层
	- server层：连接器、查询缓存、分析器、优化器、执行器，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有binlog通用日志模块。
	- 存储引擎层：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory等，其中InnoDB带有redo log。
sql语句执行过程：
	- 查询语句：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎
	- 更新语句：分析器----》权限校验----》执行器—》查询(得到数据页)-》 内存中更新 -》 redo log prepare—》binlog—》redo log commit
	
### binlog | redo log | undo log
参考[MySQL日志系统](https://blog.csdn.net/u010002184/article/details/88526708)  
从内容上讲：
- binlog 是逻辑日志，以二进制形式记录每条语句的原始逻辑，追加写；
- redo log 是InnoDB独有的，文件固定大小、循环写，记录的是数据修改之后的值，内存中对数据页修改->redo log prepare状态->修改bin log->redo log commit状态；
- undo log 是回滚日志(上面的redo是前滚)，是逻辑日志，针对每行进行记录，
从作用上讲：
- binlog 主要用于主从复制搭建等、数据库基于时间点的还原(恢复)等；
- redo log 主要用于应对意外断电的情景(crash-safe)，确保事务的持久性；
- undo log 提供事务回滚，以及多版本并发控制下的读；

### mysql四种隔离级别
- 读未提交
	- 读操作：读不加锁
	- 写操作：写加行共享锁
	事务A(只读)先开始，事务B写x行，事务A

## NoSQL
### Redis

### MongoDB
三个层次：数据库、集合、文档对象(BSON)